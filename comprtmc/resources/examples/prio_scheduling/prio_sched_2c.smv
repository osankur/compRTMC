@TIME_DOMAIN continuous

MODULE sched(_rt_ready0, is_ready0, _rt_ready1, is_ready1, increment)
VAR
    y0 : clock;
    y1 : clock;
    y2 : clock;
    x : clock;
    t : clock;
    state : {wait, p0, p1, idle, sink};
ASSIGN
    init(x) := 0;
    init(y0) := 0;
    init(y1) := 0;
    init(y2) := 0;
    init(t) := 0;
    next(t) := case
        increment : 0;
        TRUE : t;
    esac;
    init(state) := wait;
    next(state) := case
        (is_ready0 & y0 > 18) | (is_ready1 & y1 >= 18) | (y2 >= 13): sink; -- deadlines
        state = wait & is_ready0 : p0;
        state = wait & !is_ready0 & is_ready1 : p1;
        state = wait & !is_ready0 & !is_ready1 : idle;
        state = p0 & x >= 3 & x <= 7 : {p0, wait}; -- computation time p0
        state = p1 & x >= 1 & x <= 5 : {p1, wait}; -- computation time p1
        state = idle & x <= 5 : {idle, wait}; -- computation time idle
    esac;
    next(y0) := case
        _rt_ready0 : 0;
        TRUE : y0;
    esac;
    next(y1) := case
        _rt_ready1 : 0;
        TRUE : y1;
    esac;
    next(y2) := case
        next(state) = idle : 0;
        TRUE : y2;
    esac;
    next(x) := case
        state = wait : 0;
        TRUE : x;
    esac;
INVAR
      (state = p0 -> x <= 7) -- computation upper bound p0
    & (state = p1 -> x <= 5) -- computation upper bound p1
    & (state=idle -> x <= 5) -- computation upper bound idle
URGENT
    state = wait
DEFINE
    sched0 := state = p0;
    sched1 := state = p1;
    interTimeElapsed0 := y0 >= 11; -- interarrival time p0
    interTimeElapsed1 := y1 >= 8; -- interarrival time p1
    canIncrement := t > 0 & t <= 7;

MODULE main
VAR
    cmd : {check_ready0, check_ready1, cmd_sched, cmd_release, cmd_miss0, cmd_miss1, cmd_increment};
    is_ready0 : boolean;
    is_ready1 : boolean;
    err : boolean;
    nondet : boolean;
    sched : sched(_rt_ready0, is_ready0, _rt_ready1, is_ready1, _rt_increment);
    
    carry : array 0..4 of boolean;
    bits : array 0..4 of boolean;
ASSIGN
    init(bits[0]) := FALSE;
    init(bits[1]) := FALSE;
    init(bits[2]) := FALSE;
    init(bits[3]) := FALSE;

    init(carry[0]) := FALSE;
    init(carry[1]) := FALSE;
    init(carry[2]) := FALSE;
    init(carry[3]) := FALSE;
    
    next(bits[0]) := case
        bits[0] & _rt_increment : FALSE;
        !bits[0] & is_ready0 & _rt_increment : TRUE;
        bits[0] & is_ready0 & !_rt_increment : TRUE;
        !bits[0] & !_rt_increment : FALSE;
        TRUE : bits[0];
    esac;
    next(carry[0]) := case
        bits[0] & is_ready0 & _rt_increment : TRUE;
        !bits[0] & _rt_increment : FALSE;
        bits[0] & !_rt_increment : FALSE;
        !bits[0] & !_rt_increment : FALSE;
        bits[1] != !next(bits[1]) : FALSE; -- next bit will consume the carry
        TRUE : bits[0];
    esac;
	next(bits[1]) := case
        bits[1] & is_ready1 & _rt_increment & carry[0] : FALSE;
        !bits[1] & is_ready1 & _rt_increment & carry[0] : TRUE;
        bits[1] & is_ready1 & _rt_increment & !carry[0] : TRUE;
        !bits[1] & is_ready1 & _rt_increment & !carry[0] : FALSE;
        TRUE : bits[1];
    esac;
    next(carry[1]) := case
        bits[1] & is_ready1 & _rt_increment : TRUE;
        !bits[1] & _rt_increment : FALSE;
        bits[1] & !_rt_increment : FALSE;
        !bits[1] & !_rt_increment : FALSE;
        bits[2] != !next(bits[2]) : FALSE; -- next bit will consume the carry
        TRUE : bits[0];
    esac;    
	next(bits[2]) := case
        bits[2] & _rt_increment & carry[1] : FALSE;
        !bits[2] & _rt_increment & carry[1] : TRUE;
        bits[2] & _rt_increment & !carry[1] : TRUE;
        !bits[2] & _rt_increment & !carry[1] : FALSE;
        TRUE : bits[2];
    esac;
    next(carry[2]) := case
        bits[2] & _rt_increment & carry[1] : TRUE;
        !bits[2] & _rt_increment & carry[1] : FALSE;
        bits[2] & _rt_increment & !carry[1] : FALSE;
        !bits[2] & _rt_increment & !carry[1] : FALSE;
	TRUE : carry[2];
    esac;

    init(cmd) := cmd_sched;
    next(cmd) := case
        cmd = check_ready0 : check_ready1;
        cmd = check_ready1 : cmd_sched;
        cmd = cmd_sched : cmd_release;
        cmd = cmd_release : cmd_miss0;
        cmd = cmd_miss0 : cmd_miss1;
        cmd = cmd_miss1 : cmd_increment;
        cmd = cmd_increment : check_ready0;
    esac;
    init(is_ready0) := TRUE;
    next(is_ready0) := case 
        sched.sched0 : FALSE;
        _rt_ready0 & sched.interTimeElapsed0 : TRUE;
        TRUE : is_ready0;
    esac;
    init(is_ready1) := TRUE;
    next(is_ready1) := case 
        sched.sched1 : FALSE;
        _rt_ready1 & sched.interTimeElapsed1 : TRUE;
        TRUE : is_ready1;
    esac;
    init(err) := FALSE;
    next(err) := err | _rt_miss0 | _rt_miss1;
DEFINE
    _rt_miss0 := cmd = cmd_miss0 & is_ready0 & nondet;
    _rt_miss1 := cmd = cmd_miss1 & is_ready1 & nondet;
    _rt_ready0 := cmd = check_ready0 & nondet & (bits[1] | bits[2]);
    _rt_ready1 := cmd = check_ready1 & nondet & (bits[2] | bits[0]);
    _rt_idle := cmd = cmd_sched & !is_ready0 & !is_ready1;
    _rt_increment := cmd = cmd_increment & sched.canIncrement & nondet;
    error := err;
-- INVARSPEC sched.state != sink
INVARSPEC !error